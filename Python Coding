"#INVESTIGATION 1A\n",
    "import numpy as np\n",
    "\n",
    "# Constants\n",
    "A = 202\n",
    "B = 1.9\n",
    "k = 1.6 * B\n",
    "aw = 0.32\n",
    "ai = 0.62\n",
    "Tc = -10.0\n",
    "Q0 = 342.0\n",
    "\n",
    "# Functions\n",
    "abar= lambda ys : ai + (aw - ai) * ys * (1 - 0.241 * (ys**2 - 1))\n",
    "\n",
    "def a(ys):\n",
    "    if ys == 0:\n",
    "        return aw\n",
    "    else:\n",
    "        return 0.5 * (aw + ai)\n",
    "\n",
    "s = lambda ys : 1 - 0.482 * (3 * ys**2 - 1) / 2\n",
    "\n",
    "Q = lambda ys : ((Tc + A/B) * (B + k)) / (s(ys) * (1 - a(ys)) + k/B * (1 - abar(ys)))\n",
    "\n",
    "# Decrease in solar constant Q required to glaciate the Earth completely (ys = 0)\n",
    "ys = 0\n",
    "Q_glaciated = Q(ys)\n",
    "decrease_Q = Q0 - Q_glaciated\n",
    "print(\"Solar Constant Q when the earth is just fully glaciated is\", Q_glaciated)\n",
    "print(f'Decrease in Q required to glaciate Earth completely: {decrease_Q}')\n",
    "\n",
    "\n",
    "# Increase in solar constant Q required for the ice to retreat from the equator\n",
    "ys_values = np.linspace(0, 1, 1000)\n",
    "Q_values = [Q(ys) for ys in ys_values]\n",
    "Q_retreat = next(Q_value for Q_value, ys_value in zip(Q_values, ys_values) if Q_value > Q_glaciated and ys_value > 0)\n",
    "increase_Q = Q_retreat - Q_glaciated\n",
    "print(f'Increase in Q required for the ice to retreat from the equator: {increase_Q}')\n",
    "\n"
   ]

"#INVESTIGATION 1B\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "A = 202 # outgoing radiation\n",
    "B = 1.9 # outgoing radiation\n",
    "k = 1.6*B # transport parameter\n",
    "s = lambda y: 1 - 0.482*(3*y**2 - 1)/2 # solar weighting\n",
    "aw = 0.32 # water albedo\n",
    "ai = 0.62 # ice albedo\n",
    "Tc = -10.0 # critical temperature for ice formation\n",
    "Q0 = 342.0 # solar constant (1370 W/m^2 divided by 4)\n",
    "A1 = 203\n",
    "A2 = 207\n",
    "A3 = 210\n",
    "A4 = 215\n",
    "A5 = 198\n",
    "\n",
    "Qmin = ((B+k)*(Tc + A/B))/((1-aw)*(s(1)+k/B)) \n",
    "Qmax = ((B+k)*(Tc + A/B))/((1-ai)*(s(0.0)+k/B))\n",
    "\n",
    "\n",
    "abar = lambda ys: ai + (aw - ai)*ys*(1 - 0.241*(ys**2 - 1))\n",
    "Qfunc = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "Q1 = lambda ys: (Tc + A1/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "Q2 = lambda ys: (Tc + A2/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "Q3 = lambda ys: (Tc + A3/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "Q4 = lambda ys: (Tc + A4/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "Q5 = lambda ys: (Tc + A5/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Solve for the ice line\n",
    "ys = np.linspace(0, 1, 100);\n",
    "Qs = Qfunc(ys);\n",
    "Q1 = Q1(ys)\n",
    "Q2 = Q2(ys)\n",
    "Q3 = Q3(ys)\n",
    "Q4 = Q4(ys)\n",
    "Q5 = Q5(ys)\n",
    "\n",
    "plt.plot(Q5, ys, 'c', label='A=199')\n",
    "plt.plot(Qs, ys, 'k', label='A=202')\n",
    "plt.plot(Q1, ys, 'b', label='A=204')\n",
    "plt.plot(Q2, ys, 'g', label='A=207')\n",
    "plt.plot(Q3, ys, 'm', label='A=211')\n",
    "plt.plot(Q4, ys, 'y', label='A=215')\n",
    "\n",
    "\n",
    "plt.plot([Q0, Q0], [0, 1], '--')\n",
    "plt.plot([250, Qmax], [0, 0], 'b')\n",
    "plt.plot([Qmin, 550], [1, 1], 'b')\n",
    "plt.xlabel('Q');\n",
    "plt.ylabel('Ice Line ys');\n",
    "plt.grid(1)\n",
    "plt.title('Change in Q critical values as A changes')\n",
    "plt.legend()\n",
    "plt.show()\n"
   ]
    "\n",
    "# Constants\n",
    "A = 202\n",
    "B = 1.9\n",
    "k = 1.6 * B\n",
    "aw = 0.32\n",
    "ai = 0.62\n",
    "Tc = -10.0\n",
    "Q0 = 342.0\n",
    "A1 = 203\n",
    "A2 = 207\n",
    "A3 = 210\n",
    "A4 = 215\n",
    "A5 = 198\n",
    "\n",
    "# Functions\n",
    "abar= lambda ys : ai + (aw - ai) * ys * (1 - 0.241 * (ys**2 - 1))\n",
    "\n",
    "def a(ys):\n",
    "    if ys == 0:\n",
    "        return aw\n",
    "    else:\n",
    "        return 0.5 * (aw + ai)\n",
    "\n",
    "s = lambda ys : 1 - 0.482 * (3 * ys**2 - 1) / 2\n",
    "\n",
    "Q = lambda ys : ((Tc + A/B) * (B + k)) / (s(ys) * (1 - a(ys)) + k/B * (1 - abar(ys)))\n",
    "Q1 = lambda ys : ((Tc + A1/B) * (B + k)) / (s(ys) * (1 - a(ys)) + k/B * (1 - abar(ys)))\n",
    "Q2 = lambda ys : ((Tc + A2/B) * (B + k)) / (s(ys) * (1 - a(ys)) + k/B * (1 - abar(ys)))\n",
    "Q3 = lambda ys : ((Tc + A3/B) * (B + k)) / (s(ys) * (1 - a(ys)) + k/B * (1 - abar(ys)))\n",
    "Q4 = lambda ys : ((Tc + A4/B) * (B + k)) / (s(ys) * (1 - a(ys)) + k/B * (1 - abar(ys)))\n",
    "Q5 = lambda ys : ((Tc + A5/B) * (B + k)) / (s(ys) * (1 - a(ys)) + k/B * (1 - abar(ys)))\n",
    "\n",
    "# Decrease in solar constant Q required to glaciate the Earth completely (ys = 0)\n",
    "ys = 0\n",
    "Q_glaciated = Q(ys)\n",
    "Q1_glaciated = Q1(ys)\n",
    "Q2_glaciated = Q2(ys)\n",
    "Q3_glaciated = Q3(ys)\n",
    "Q4_glaciated = Q4(ys)\n",
    "Q5_glaciated = Q5(ys)\n",
    "decrease_Q = Q0 - Q_glaciated\n",
    "decrease_Q1 = Q0 - Q1_glaciated\n",
    "decrease_Q2 = Q0 - Q2_glaciated\n",
    "decrease_Q3 = Q0 - Q3_glaciated\n",
    "decrease_Q4 = Q0 - Q4_glaciated\n",
    "decrease_Q5 = Q0 - Q5_glaciated\n",
    "print(\"At A=198, Solar Constant Q when the earth is just fully glaciated is\", Q5_glaciated)\n",
    "print(f'At A=198, Decrease in Q required to glaciate Earth completely: {decrease_Q5}')\n",
    "\n",
    "print(\"At A=202, Solar Constant Q when the earth is just fully glaciated is\", Q_glaciated)\n",
    "print(f'At A=202, Decrease in Q required to glaciate Earth completely: {decrease_Q}')\n",
    "\n",
    "print(\"At A=203, Solar Constant Q when the earth is just fully glaciated is\", Q1_glaciated)\n",
    "print(f'At A=203, Decrease in Q required to glaciate Earth completely: {decrease_Q1}')\n",
    "\n",
    "print(\"At A=207, Solar Constant Q when the earth is just fully glaciated is\", Q2_glaciated)\n",
    "print(f'At A=207, Decrease in Q required to glaciate Earth completely: {decrease_Q2}')\n",
    "\n",
    "print(\"At A=210, Solar Constant Q when the earth is just fully glaciated is\", Q3_glaciated)\n",
    "print(f'At A=210, Decrease in Q required to glaciate Earth completely: {decrease_Q3}')\n",
    "\n",
    "print(\"At A=215, Solar Constant Q when the earth is just fully glaciated is\", Q4_glaciated)\n",
    "print(f'At A=215, Decrease in Q required to glaciate Earth completely: {decrease_Q4}')\n",
    "\n",
    "\n",
    "Q1_values = [Q1(ys) for ys in ys_values]\n",
    "Q2_values = [Q2(ys) for ys in ys_values]\n",
    "Q3_values = [Q3(ys) for ys in ys_values]\n",
    "Q4_values = [Q4(ys) for ys in ys_values]\n",
    "Q5_values = [Q5(ys) for ys in ys_values]\n",
    "\n",
    "# Increase in solar constant Q required for the ice to retreat from the equator\n",
    "ys_values = np.linspace(0, 1, 1000)\n",
    "Q_values = [Q(ys) for ys in ys_values]\n",
    "\n",
    "Q5_values = [Q5(ys) for ys in ys_values]\n",
    "Q5_retreat = next(Q5_value for Q5_value, ys_value in zip(Q5_values, ys_values) if Q5_value > Q5_glaciated and ys_value > 0)\n",
    "increase_Q5 = Q5_retreat - Q5_glaciated\n",
    "print(f'At A=198, Increase in Q required for the ice to retreat from the equator: {increase_Q5}')\n",
    "\n",
    "\n",
    "Q_retreat = next(Q_value for Q_value, ys_value in zip(Q_values, ys_values) if Q_value > Q_glaciated and ys_value > 0)\n",
    "increase_Q = Q_retreat - Q_glaciated\n",
    "print(f'At A=202, Increase in Q required for the ice to retreat from the equator: {increase_Q}')\n",
    "\n",
    "\n",
    "Q1_values = [Q1(ys) for ys in ys_values]\n",
    "Q1_retreat = next(Q1_value for Q1_value, ys_value in zip(Q1_values, ys_values) if Q1_value > Q1_glaciated and ys_value > 0)\n",
    "increase_Q1 = Q1_retreat - Q1_glaciated\n",
    "print(f'At A=203, Increase in Q required for the ice to retreat from the equator: {increase_Q1}')\n",
    "\n",
    "\n",
    "Q2_values = [Q2(ys) for ys in ys_values]\n",
    "Q2_retreat = next(Q2_value for Q2_value, ys_value in zip(Q2_values, ys_values) if Q2_value > Q2_glaciated and ys_value > 0)\n",
    "increase_Q2 = Q2_retreat - Q2_glaciated\n",
    "print(f'At A=205, Increase in Q required for the ice to retreat from the equator: {increase_Q2}')\n",
    "\n",
    "Q3_values = [Q3(ys) for ys in ys_values]\n",
    "Q3_retreat = next(Q3_value for Q3_value, ys_value in zip(Q3_values, ys_values) if Q3_value > Q3_glaciated and ys_value > 0)\n",
    "increase_Q3 = Q3_retreat - Q3_glaciated\n",
    "print(f'At A=210, Increase in Q required for the ice to retreat from the equator: {increase_Q3}')\n",
    "\n",
    "Q4_values = [Q4(ys) for ys in ys_values]\n",
    "Q4_retreat = next(Q4_value for Q4_value, ys_value in zip(Q4_values, ys_values) if Q4_value > Q4_glaciated and ys_value > 0)\n",
    "increase_Q4 = Q4_retreat - Q4_glaciated\n",
    "print(f'At A=215, Increase in Q required for the ice to retreat from the equator: {increase_Q4}')\n",
    "\n"
   ]


"# Constants\n",
    "Tc = -10.0\n",
    "Q0 = 342.0\n",
    "B = 1.9\n",
    "k = 1.6 * B\n",
    "ai = 0.62\n",
    "aw = 0.32\n",
    "\n",
    "# Functions\n",
    "def abar(ys, ai, aw):\n",
    "    return ai + (aw - ai) * ys * (1 - 0.241 * (ys**2 - 1))\n",
    "\n",
    "def a(ys, ai, aw):\n",
    "    if ys == 0:\n",
    "        return aw\n",
    "    else:\n",
    "        return 0.5 * (aw + ai)\n",
    "\n",
    "def s(ys):\n",
    "    return 1 - 0.482 * (3 * ys**2 - 1) / 2\n",
    "\n",
    "def Q(A, B, k, ai, aw):\n",
    "    return ((Tc + A/B) * (B + k)) / (s(0) * (1 - a(0, ai, aw)) + k/B * (1 - abar(0, ai, aw)))\n",
    "\n",
    "# Generate a range of A values\n",
    "A_values = np.linspace(180, 220, 100)\n",
    "\n",
    "# Calculate Q values for each A value\n",
    "Q_values = np.array([Q(A, B, k, ai, aw) for A in A_values])\n",
    "\n",
    "# Plot Q values against A values\n",
    "plt.plot(A_values, Q_values)\n",
    "plt.xlabel(\"A\")\n",
    "plt.ylabel(\"Q\")\n",
    "plt.title(\"Solar constant Q to glaciate Earth vs A\")\n",
    "plt.grid()\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# Generate a range of A values\n",
    "A_values = np.linspace(180, 220, 100)\n",
    "\n",
    "# Calculate Q values for each A value\n",
    "Q_retreat = Q0-Q_values\n",
    "\n",
    "# Plot Q values against A values\n",
    "plt.plot(A_values, Q_retreat)\n",
    "plt.plot([180,220],[0,0],\"--\")\n",
    "plt.xlabel(\"A\")\n",
    "plt.ylabel(\"Q decrease \")\n",
    "plt.title(\"Solar constant Q decrease to glaciate Earth vs A\")\n",
    "plt.grid()\n",
    "plt.show()"
   ]


"# CHANGE IN B\n",
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "A = 202 # outgoing radiation\n",
    "B = 1.9 # outgoing radiation\n",
    "k = 1.6*B # transport parameter\n",
    "s = lambda y: 1 - 0.482*(3*y**2 - 1)/2 # solar weighting\n",
    "aw = 0.32 # water albedo\n",
    "ai = 0.62 # ice albedo\n",
    "Tc = -10.0 # critical temperature for ice formation\n",
    "Q0 = 342.0 # solar constant (1370 W/m^2 divided by 4)\n",
    "B1 = 1\n",
    "k1 = 1.6*B1\n",
    "B2 = 1.3\n",
    "k2 = 1.6*B2\n",
    "B3 = 1.7\n",
    "k3 = 1.6*B3\n",
    "B4 = 2.2\n",
    "k4 = 1.6*B4\n",
    "B5 = 2.4\n",
    "k5 = 1.6*B5\n",
    "B6 = 2.6\n",
    "k6 = 1.6*B6\n",
    "\n",
    "Qmin = ((B+k)*(Tc + A/B))/((1-aw)*(s(1)+k/B)) \n",
    "Qmax = ((B+k)*(Tc + A/B))/((1-ai)*(s(0.0)+k/B))\n",
    "\n",
    "\n",
    "# Note version in lectures was a 1/2 factor off on the second grouping of terms; \n",
    "# now corrected to match Q6 of PS4\n",
    "abar = lambda ys: ai + (aw - ai)*ys*(1 - 0.241*(ys**2 - 1))\n",
    "Qfunc = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "Q1 = lambda ys: (Tc + A/B1)*(B1+k1)/(s(ys)*(1 - (ai+aw)/2) + k1/B1*(1 - abar(ys)))\n",
    "Q2 = lambda ys: (Tc + A/B2)*(B2+k2)/(s(ys)*(1 - (ai+aw)/2) + k2/B2*(1 - abar(ys)))\n",
    "Q3 = lambda ys: (Tc + A/B3)*(B3+k3)/(s(ys)*(1 - (ai+aw)/2) + k3/B3*(1 - abar(ys)))\n",
    "Q4 = lambda ys: (Tc + A/B4)*(B4+k4)/(s(ys)*(1 - (ai+aw)/2) + k4/B4*(1 - abar(ys)))\n",
    "Q5 = lambda ys: (Tc + A/B5)*(B5+k5)/(s(ys)*(1 - (ai+aw)/2) + k5/B5*(1 - abar(ys)))\n",
    "Q6 = lambda ys: (Tc + A/B6)*(B6+k6)/(s(ys)*(1 - (ai+aw)/2) + k6/B6*(1 - abar(ys)))\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Solve for the ice line\n",
    "ys = np.linspace(0, 1, 100);\n",
    "Qs = Qfunc(ys);\n",
    "Q1 = Q1(ys)\n",
    "Q2 = Q2(ys)\n",
    "Q3 = Q3(ys)\n",
    "Q4 = Q4(ys)\n",
    "Q5 = Q5(ys)\n",
    "Q6 = Q6(ys)\n",
    "\n",
    "B1 = 1\n",
    "k1 = 1.6*B1\n",
    "B2 = 1.3\n",
    "k2 = 1.6*B2\n",
    "B3 = 1.7\n",
    "k3 = 1.6*B3\n",
    "B4 = 2.2\n",
    "k4 = 1.6*B4\n",
    "B5 = 2.4\n",
    "k5 = 1.6*B5\n",
    "B6 = 2.6\n",
    "k6 = 1.6*B6\n",
    "\n",
    "plt.plot(Q1, ys, 'c', label='B=1')\n",
    "plt.plot(Q2, ys, 'k', label='B=1.3')\n",
    "plt.plot(Q3, ys, 'y', label='B=1.7')\n",
    "plt.plot(Qs, ys, 'm', label='B=1.9')\n",
    "plt.plot(Q4, ys, 'g', label='B=2.2')\n",
    "plt.plot(Q5, ys, 'red', label='B=2.4')\n",
    "plt.plot(Q6, ys, 'b', label='B=2.6')\n",
    "\n",
    "plt.plot([Q0, Q0], [0, 1], '--')\n",
    "plt.plot([250, Qmax], [0, 0], 'b')\n",
    "plt.plot([Qmin, 550], [1, 1], 'b')\n",
    "plt.xlabel('Q');\n",
    "plt.ylabel('Ice Line ys');\n",
    "plt.grid(1)\n",
    "plt.title('Change in Q critical values as B changes')\n",
    "plt.legend()\n",
    "plt.show()"
   ]


"# Constants\n",
    "Tc = -10.0\n",
    "Q0 = 342.0\n",
    "A = 200\n",
    "k = 1.6\n",
    "ai = 0.62\n",
    "aw = 0.32\n",
    "\n",
    "# Functions\n",
    "def abar(ys, ai, aw):\n",
    "    return ai + (aw - ai) * ys * (1 - 0.241 * (ys**2 - 1))\n",
    "\n",
    "def a(ys, ai, aw):\n",
    "    if ys == 0:\n",
    "        return aw\n",
    "    else:\n",
    "        return 0.5 * (aw + ai)\n",
    "\n",
    "def s(ys):\n",
    "    return 1 - 0.482 * (3 * ys**2 - 1) / 2\n",
    "\n",
    "def Q(A, B, k, ai, aw):\n",
    "    return ((Tc + A/B) * (B + k)) / (s(0) * (1 - aw) + k/B * (1 - ai))\n",
    "\n",
    "\n",
    "\n",
    "# Calculate Q values for each B value\n",
    "k_values = 1.6 * B_values\n",
    "Q_values = np.array([Q(A, B, k, ai, aw) for B, k in zip(B_values, k_values)])\n",
    "\n",
    "\n",
    "# Generate a range of B values\n",
    "B_values = np.linspace(0, 3, 100)\n",
    "\n",
    "# Calculate Q values for each B value\n",
    "Q_retreat = Q0 - Q_values\n",
    "\n",
    "# Plot Q values against B values\n",
    "plt.plot(B_values, Q_retreat)\n",
    "plt.plot([0, 3], [0, 0], \"--\")\n",
    "plt.xlabel(\"B\")\n",
    "plt.ylabel(\"Q decrease\")\n",
    "plt.title(\"Solar constant Q decrease to glaciate Earth vs B\")\n",
    "plt.grid()\n",
    "plt.show()"
   ]


"# Constants\n",
    "A = 202 # outgoing radiation\n",
    "B = 1.9 # outgoing radiation\n",
    "k = 1.6*B # transport parameter\n",
    "s = lambda y: 1 - 0.482*(3*y**2 - 1)/2 # solar weighting\n",
    "aw = 0.32 # water albedo\n",
    "ai = 0.62 # ice albedo\n",
    "Tc = -10.0 # critical temperature for ice formation\n",
    "Q0 = 342.0 # solar constant (1370 W/m^2 divided by 4)\n",
    "B1 = 2.2\n",
    "k1 = 1.6*B1\n",
    "B2 = 2.4\n",
    "k2 = 1.6*B2\n",
    "B3 = 2.6\n",
    "k3 = 1.6*B3\n",
    "B4 = 1.7\n",
    "k4 = 1.6*B4\n",
    "B5 = 1.3\n",
    "k5 = 1.6*B5\n",
    "B6 = 1\n",
    "k6 = 1.6*B6\n",
    "\n",
    "# Functions\n",
    "abar= lambda ys : ai + (aw - ai) * ys * (1 - 0.241 * (ys**2 - 1))\n",
    "\n",
    "def a(ys):\n",
    "    if ys == 0:\n",
    "        return aw\n",
    "    else:\n",
    "        return 0.5 * (aw + ai)\n",
    "\n",
    "s = lambda ys : 1 - 0.482 * (3 * ys**2 - 1) / 2\n",
    "\n",
    "Q = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - a(ys)) + k/B*(1 - abar(ys)))\n",
    "Q1 = lambda ys: (Tc + A/B1)*(B1+k1)/(s(ys)*(1 - a(ys)) + k1/B1*(1 - abar(ys)))\n",
    "Q2 = lambda ys: (Tc + A/B2)*(B2+k2)/(s(ys)*(1 - a(ys)) + k2/B2*(1 - abar(ys)))\n",
    "Q3 = lambda ys: (Tc + A/B3)*(B3+k3)/(s(ys)*(1 - a(ys)) + k3/B3*(1 - abar(ys)))\n",
    "Q4 = lambda ys: (Tc + A/B4)*(B4+k4)/(s(ys)*(1 - a(ys)) + k4/B4*(1 - abar(ys)))\n",
    "Q5 = lambda ys: (Tc + A/B5)*(B5+k5)/(s(ys)*(1 - a(ys)) + k5/B5*(1 - abar(ys)))\n",
    "Q6 = lambda ys: (Tc + A/B6)*(B6+k6)/(s(ys)*(1 - a(ys)) + k6/B6*(1 - abar(ys)))\n",
    "\n",
    "\n",
    "\n",
    "# Decrease in solar constant Q required to glaciate the Earth completely (ys = 0)\n",
    "ys = 0\n",
    "Q_glaciated = Q(ys)\n",
    "Q1_glaciated = Q1(ys)\n",
    "Q2_glaciated = Q2(ys)\n",
    "Q3_glaciated = Q3(ys)\n",
    "Q4_glaciated = Q4(ys)\n",
    "Q5_glaciated = Q5(ys)\n",
    "Q6_glaciated = Q6(ys)\n",
    "decrease_Q = Q0 - Q_glaciated\n",
    "decrease_Q1 = Q0 - Q1_glaciated\n",
    "decrease_Q2 = Q0 - Q2_glaciated\n",
    "decrease_Q3 = Q0 - Q3_glaciated\n",
    "decrease_Q4 = Q0 - Q4_glaciated\n",
    "decrease_Q5 = Q0 - Q5_glaciated\n",
    "decrease_Q6 = Q0 - Q6_glaciated\n",
    "\n",
    "print(\"At B=1, Solar Constant Q when the earth is just fully glaciated is\", Q6_glaciated)\n",
    "print(f'At B=1, Decrease in Q required to glaciate Earth completely: {decrease_Q6}')\n",
    "\n",
    "print(\"At B=1.3, Solar Constant Q when the earth is just fully glaciated is\", Q5_glaciated)\n",
    "print(f'At B=1.3, Decrease in Q required to glaciate Earth completely: {decrease_Q5}')\n",
    "\n",
    "print(\"At B=1.7, Solar Constant Q when the earth is just fully glaciated is\", Q4_glaciated)\n",
    "print(f'At B=1.7, Decrease in Q required to glaciate Earth completely: {decrease_Q4}')\n",
    "\n",
    "print(\"At B=1.9, Solar Constant Q when the earth is just fully glaciated is\", Q_glaciated)\n",
    "print(f'At B=1.9, Decrease in Q required to glaciate Earth completely: {decrease_Q}')\n",
    "\n",
    "print(\"At B=2.2, Solar Constant Q when the earth is just fully glaciated is\", Q1_glaciated)\n",
    "print(f'At B=2.2, Decrease in Q required to glaciate Earth completely: {decrease_Q1}')\n",
    "\n",
    "print(\"At B=2.4, Solar Constant Q when the earth is just fully glaciated is\", Q2_glaciated)\n",
    "print(f'At B=2.4, Decrease in Q required to glaciate Earth completely: {decrease_Q2}')\n",
    "\n",
    "print(\"At B=2.6, Solar Constant Q when the earth is just fully glaciated is\", Q3_glaciated)\n",
    "print(f'At B=2.6, Decrease in Q required to glaciate Earth completely: {decrease_Q3}')\n",
    "\n",
    "\n",
    "# Increase in solar constant Q required for the ice to retreat from the equator\n",
    "ys_values = np.linspace(0, 1, 1000)\n",
    "\n",
    "\n",
    "Q6_values = [Q6(ys) for ys in ys_values]\n",
    "Q6_retreat = next(Q6_value for Q6_value, ys_value in zip(Q6_values, ys_values) if Q6_value > Q6_glaciated and ys_value > 0)\n",
    "increase_Q6 = Q6_retreat - Q6_glaciated\n",
    "print(f'At B=1, Increase in Q required for the ice to retreat from the equator: {increase_Q6}')\n",
    "\n",
    "Q5_values = [Q5(ys) for ys in ys_values]\n",
    "Q5_retreat = next(Q5_value for Q5_value, ys_value in zip(Q5_values, ys_values) if Q5_value > Q5_glaciated and ys_value > 0)\n",
    "increase_Q5 = Q5_retreat - Q5_glaciated\n",
    "print(f'At B=1.3, Increase in Q required for the ice to retreat from the equator: {increase_Q5}')\n",
    "\n",
    "Q4_values = [Q4(ys) for ys in ys_values]\n",
    "Q4_retreat = next(Q4_value for Q4_value, ys_value in zip(Q4_values, ys_values) if Q4_value > Q4_glaciated and ys_value > 0)\n",
    "increase_Q4 = Q4_retreat - Q4_glaciated\n",
    "print(f'At B=1.7, Increase in Q required for the ice to retreat from the equator: {increase_Q4}')\n",
    "\n",
    "Q_values = [Q(ys) for ys in ys_values]\n",
    "Q_retreat = next(Q_value for Q_value, ys_value in zip(Q_values, ys_values) if Q_value > Q_glaciated and ys_value > 0)\n",
    "increase_Q = Q_retreat - Q_glaciated\n",
    "print(f'At B=1.9, Increase in Q required for the ice to retreat from the equator: {increase_Q}')\n",
    "\n",
    "\n",
    "Q1_values = [Q1(ys) for ys in ys_values]\n",
    "Q1_retreat = next(Q1_value for Q1_value, ys_value in zip(Q1_values, ys_values) if Q1_value > Q1_glaciated and ys_value > 0)\n",
    "increase_Q1 = Q1_retreat - Q1_glaciated\n",
    "print(f'At B=2.2, Increase in Q required for the ice to retreat from the equator: {increase_Q1}')\n",
    "\n",
    "\n",
    "Q2_values = [Q2(ys) for ys in ys_values]\n",
    "Q2_retreat = next(Q2_value for Q2_value, ys_value in zip(Q2_values, ys_values) if Q2_value > Q2_glaciated and ys_value > 0)\n",
    "increase_Q2 = Q2_retreat - Q2_glaciated\n",
    "print(f'At B=2.4, Increase in Q required for the ice to retreat from the equator: {increase_Q2}')\n",
    "\n",
    "Q3_values = [Q3(ys) for ys in ys_values]\n",
    "Q3_retreat = next(Q3_value for Q3_value, ys_value in zip(Q3_values, ys_values) if Q3_value > Q3_glaciated and ys_value > 0)\n",
    "increase_Q3 = Q3_retreat - Q3_glaciated\n",
    "print(f'At B=2.6, Increase in Q required for the ice to retreat from the equator: {increase_Q3}')\n"
   ]


 "import matplotlib.pyplot as plt\n",
    "A = 202 # outgoing radiation\n",
    "B = 1.9 # outgoing radiation\n",
    "k = 1.6*B # transport parameter\n",
    "s = lambda y: 1 - 0.482*(3*y**2 - 1)/2 # solar weighting\n",
    "aw = 0.32 # water albedo\n",
    "ai = 0.62 # ice albedo\n",
    "Tc = -10.0 # critical temperature for ice formation\n",
    "Q0 = 342.0 # solar constant (1370 W/m^2 divided by 4)\n",
    "k1 = 2.8\n",
    "k2 = 3\n",
    "k3 = 3.5\n",
    "k4 = 3.74\n",
    "k5 = 3.91\n",
    "k6 = 4\n",
    "\n",
    "\n",
    "Qmin = ((B+k)*(Tc + A/B))/((1-aw)*(s(1)+k/B)) \n",
    "Qmax = ((B+k)*(Tc + A/B))/((1-ai)*(s(0.0)+k/B))\n",
    "\n",
    "\n",
    "# Note version in lectures was a 1/2 factor off on the second grouping of terms; \n",
    "# now corrected to match Q6 of PS4\n",
    "abar = lambda ys: ai + (aw - ai)*ys*(1 - 0.241*(ys**2 - 1))\n",
    "Qfunc = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "Q1 = lambda ys: (Tc + A/B)*(B+k1)/(s(ys)*(1 - (ai+aw)/2) + k1/B*(1 - abar(ys)))\n",
    "Q2 = lambda ys: (Tc + A/B)*(B+k2)/(s(ys)*(1 - (ai+aw)/2) + k2/B*(1 - abar(ys)))\n",
    "Q3 = lambda ys: (Tc + A/B)*(B+k3)/(s(ys)*(1 - (ai+aw)/2) + k3/B*(1 - abar(ys)))\n",
    "Q4 = lambda ys: (Tc + A/B)*(B+k4)/(s(ys)*(1 - (ai+aw)/2) + k4/B*(1 - abar(ys)))\n",
    "Q5 = lambda ys: (Tc + A/B)*(B+k5)/(s(ys)*(1 - (ai+aw)/2) + k5/B*(1 - abar(ys)))\n",
    "Q6 = lambda ys: (Tc + A/B)*(B+k6)/(s(ys)*(1 - (ai+aw)/2) + k6/B*(1 - abar(ys)))\n",
    "\n",
    "\n",
    "\n",
    "# Solve for the ice line\n",
    "ys = np.linspace(0, 1, 100);\n",
    "Qs = Qfunc(ys);\n",
    "Q1 = Q1(ys)\n",
    "Q2 = Q2(ys)\n",
    "Q3 = Q3(ys)\n",
    "Q4 = Q4(ys)\n",
    "Q5 = Q5(ys)\n",
    "Q6 = Q6(ys)\n",
    "\n",
    "\n",
    "plt.plot(Q6, ys, 'c', label='k=4')\n",
    "plt.plot(Q5, ys, 'k', label='k=3.91')\n",
    "plt.plot(Q4, ys, 'y', label='k=3.74')\n",
    "plt.plot(Q3, ys, 'm', label='k=3.5')\n",
    "plt.plot(Qs, ys, 'k', label='k=3.04')\n",
    "plt.plot(Q2, ys, 'g', label='k=3')\n",
    "plt.plot(Q1, ys, 'b', label='k=2.8')\n",
    "\n",
    "\n",
    "\n",
    "plt.plot([Q0, Q0], [0, 1], '--')\n",
    "plt.plot([250, Qmax], [0, 0], 'b')\n",
    "plt.plot([Qmin, 550], [1, 1], 'b')\n",
    "plt.xlabel('Q');\n",
    "plt.ylabel('Ice Line ys');\n",
    "plt.grid(1)\n",
    "plt.title('Change in Q behaviour as k changes')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "71956955-7bc6-4290-9bf0-5537ea0991e0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "At k=2.8, Solar Constant Q when the earth is just fully glaciated is 322.4522113900873\n",
      "At k=2.8, Decrease in Q required to glaciate Earth completely: 19.547788609912686\n",
      "At k=3, Solar Constant Q when the earth is just fully glaciated is 326.86052055645393\n",
      "At k=3, Decrease in Q required to glaciate Earth completely: 15.139479443546065\n",
      "At k=3.04, Solar Constant Q when the earth is just fully glaciated is 327.71303413505245\n",
      "At k=3.04, Decrease in Q required to glaciate Earth completely: 14.286965864947547\n",
      "At k=3.5, Solar Constant Q when the earth is just fully glaciated is 336.88192292010694\n",
      "At k=3.5, Decrease in Q required to glaciate Earth completely: 5.118077079893055\n",
      "At k=3.74, Solar Constant Q when the earth is just fully glaciated is 341.2449761486915\n",
      "At k=3.74, Decrease in Q required to glaciate Earth completely: 0.7550238513085219\n",
      "At k=3,91, Solar Constant Q when the earth is just fully glaciated is 344.1796054088281\n",
      "At k=3.91, Decrease in Q required to glaciate Earth completely: -2.179605408828081\n",
      "At k=4, Solar Constant Q when the earth is just fully glaciated is 345.6840875822669\n",
      "At k=4, Decrease in Q required to glaciate Earth completely: -3.6840875822668977\n",
      "At k=2.8, Increase in Q required for the ice to retreat from the equator: 49.124642712406796\n",
      "At k=3, Increase in Q required for the ice to retreat from the equator: 48.201547215171615\n",
      "At k=3.04, Increase in Q required for the ice to retreat from the equator: 48.019629099343774\n",
      "At k=3.5, Increase in Q required for the ice to retreat from the equator: 45.99432257587796\n",
      "At k=3.74, Increase in Q required for the ice to retreat from the equator: 44.98699598995182\n",
      "At k=3.91, Increase in Q required for the ice to retreat from the equator: 44.29389831639105\n",
      "At k=4, Increase in Q required for the ice to retreat from the equator: 44.29389831639105\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "A = 202 # outgoing radiation\n",
    "B = 1.9 # outgoing radiation\n",
    "k = 1.6*B # transport parameter 3.04\n",
    "s = lambda y: 1 - 0.482*(3*y**2 - 1)/2 # solar weighting\n",
    "aw = 0.32 # water albedo\n",
    "ai = 0.62 # ice albedo\n",
    "Tc = -10.0 # critical temperature for ice formation\n",
    "Q0 = 342.0 # solar constant (1370 W/m^2 divided by 4)\n",
    "k1 = 2.8\n",
    "k2 = 3\n",
    "k3 = 3.5\n",
    "k4 = 3.74\n",
    "k5 = 3.91\n",
    "k6 = 4\n",
    "\n",
    "\n",
    "# Functions\n",
    "abar= lambda ys : ai + (aw - ai) * ys * (1 - 0.241 * (ys**2 - 1))\n",
    "\n",
    "def a(ys):\n",
    "    if ys == 0:\n",
    "          return aw\n",
    "    else:\n",
    "          return 0.5 * (aw + ai)\n",
    "\n",
    "s = lambda ys : 1 - 0.482 * (3 * ys**2 - 1) / 2\n",
    "\n",
    "Q = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - a(ys)) + k/B*(1 - abar(ys)))\n",
    "Q1 = lambda ys: (Tc + A/B)*(B+k1)/(s(ys)*(1 - a(ys)) + k1/B*(1 - abar(ys)))\n",
    "Q2 = lambda ys: (Tc + A/B)*(B+k2)/(s(ys)*(1 - a(ys)) + k2/B*(1 - abar(ys)))\n",
    "Q3 = lambda ys: (Tc + A/B)*(B+k3)/(s(ys)*(1 - a(ys)) + k3/B*(1 - abar(ys)))\n",
    "Q4 = lambda ys: (Tc + A/B)*(B+k4)/(s(ys)*(1 - a(ys)) + k4/B*(1 - abar(ys)))\n",
    "Q5 = lambda ys: (Tc + A/B)*(B+k5)/(s(ys)*(1 - a(ys)) + k5/B*(1 - abar(ys)))\n",
    "Q6 = lambda ys: (Tc + A/B)*(B+k6)/(s(ys)*(1 - a(ys)) + k6/B*(1 - abar(ys)))\n",
    "\n",
    "\n",
    "\n",
    "# Decrease in solar constant Q required to glaciate the Earth completely (ys = 0)\n",
    "ys = 0\n",
    "Q_glaciated = Q(ys)\n",
    "Q1_glaciated = Q1(ys)\n",
    "Q2_glaciated = Q2(ys)\n",
    "Q3_glaciated = Q3(ys)\n",
    "Q4_glaciated = Q4(ys)\n",
    "Q5_glaciated = Q5(ys)\n",
    "Q6_glaciated = Q6(ys)\n",
    "decrease_Q = Q0 - Q_glaciated\n",
    "decrease_Q1 = Q0 - Q1_glaciated\n",
    "decrease_Q2 = Q0 - Q2_glaciated\n",
    "decrease_Q3 = Q0 - Q3_glaciated\n",
    "decrease_Q4 = Q0 - Q4_glaciated\n",
    "decrease_Q5 = Q0 - Q5_glaciated\n",
    "decrease_Q6 = Q0 - Q6_glaciated\n",
    "\n",
    "\n",
    "\n",
    "print(\"At k=2.8, Solar Constant Q when the earth is just fully glaciated is\", Q1_glaciated)\n",
    "print(f'At k=2.8, Decrease in Q required to glaciate Earth completely: {decrease_Q1}')\n",
    "\n",
    "print(\"At k=3, Solar Constant Q when the earth is just fully glaciated is\", Q2_glaciated)\n",
    "print(f'At k=3, Decrease in Q required to glaciate Earth completely: {decrease_Q2}')\n",
    "\n",
    "print(\"At k=3.04, Solar Constant Q when the earth is just fully glaciated is\", Q_glaciated)\n",
    "print(f'At k=3.04, Decrease in Q required to glaciate Earth completely: {decrease_Q}')\n",
    "\n",
    "print(\"At k=3.5, Solar Constant Q when the earth is just fully glaciated is\", Q3_glaciated)\n",
    "print(f'At k=3.5, Decrease in Q required to glaciate Earth completely: {decrease_Q3}')\n",
    "\n",
    "print(\"At k=3.74, Solar Constant Q when the earth is just fully glaciated is\", Q4_glaciated)\n",
    "print(f'At k=3.74, Decrease in Q required to glaciate Earth completely: {decrease_Q4}')\n",
    "\n",
    "print(\"At k=3,91, Solar Constant Q when the earth is just fully glaciated is\", Q5_glaciated)\n",
    "print(f'At k=3.91, Decrease in Q required to glaciate Earth completely: {decrease_Q5}')\n",
    "\n",
    "print(\"At k=4, Solar Constant Q when the earth is just fully glaciated is\", Q6_glaciated)\n",
    "print(f'At k=4, Decrease in Q required to glaciate Earth completely: {decrease_Q6}')\n",
    "\n",
    "# Increase in solar constant Q required for the ice to retreat from the equator\n",
    "ys_values = np.linspace(0, 1, 1000)\n",
    "\n",
    "\n",
    "\n",
    "Q1_values = [Q1(ys) for ys in ys_values]\n",
    "Q1_retreat = next(Q1_value for Q1_value, ys_value in zip(Q1_values, ys_values) if Q1_value > Q1_glaciated and ys_value > 0)\n",
    "increase_Q1 = Q1_retreat - Q1_glaciated\n",
    "print(f'At k=2.8, Increase in Q required for the ice to retreat from the equator: {increase_Q1}')\n",
    "\n",
    "\n",
    "Q2_values = [Q2(ys) for ys in ys_values]\n",
    "Q2_retreat = next(Q2_value for Q2_value, ys_value in zip(Q2_values, ys_values) if Q2_value > Q2_glaciated and ys_value > 0)\n",
    "increase_Q2 = Q2_retreat - Q2_glaciated\n",
    "print(f'At k=3, Increase in Q required for the ice to retreat from the equator: {increase_Q2}')\n",
    "\n",
    "Q_values = [Q(ys) for ys in ys_values]\n",
    "Q_retreat = next(Q_value for Q_value, ys_value in zip(Q_values, ys_values) if Q_value > Q_glaciated and ys_value > 0)\n",
    "increase_Q = Q_retreat - Q_glaciated\n",
    "print(f'At k=3.04, Increase in Q required for the ice to retreat from the equator: {increase_Q}')\n",
    "\n",
    "Q3_values = [Q3(ys) for ys in ys_values]\n",
    "Q3_retreat = next(Q3_value for Q3_value, ys_value in zip(Q3_values, ys_values) if Q3_value > Q3_glaciated and ys_value > 0)\n",
    "increase_Q3 = Q3_retreat - Q3_glaciated\n",
    "print(f'At k=3.5, Increase in Q required for the ice to retreat from the equator: {increase_Q3}')\n",
    "\n",
    "Q4_values = [Q4(ys) for ys in ys_values]\n",
    "Q4_retreat = next(Q4_value for Q4_value, ys_value in zip(Q4_values, ys_values) if Q4_value > Q4_glaciated and ys_value > 0)\n",
    "increase_Q4 = Q4_retreat - Q4_glaciated\n",
    "print(f'At k=3.74, Increase in Q required for the ice to retreat from the equator: {increase_Q4}')\n",
    "\n",
    "Q5_values = [Q5(ys) for ys in ys_values]\n",
    "Q5_retreat = next(Q5_value for Q5_value, ys_value in zip(Q5_values, ys_values) if Q5_value > Q5_glaciated and ys_value > 0)\n",
    "increase_Q5 = Q5_retreat - Q5_glaciated\n",
    "print(f'At k=3.91, Increase in Q required for the ice to retreat from the equator: {increase_Q5}')\n",
    "\n",
    "Q6_values = [Q6(ys) for ys in ys_values]\n",
    "Q6_retreat = next(Q6_value for Q6_value, ys_value in zip(Q6_values, ys_values) if Q6_value > Q6_glaciated and ys_value > 0)\n",
    "increase_Q6 = Q6_retreat - Q6_glaciated\n",
    "print(f'At k=4, Increase in Q required for the ice to retreat from the equator: {increase_Q5}')\n"
   ]


"# Constants\n",
    "Tc = -10.0\n",
    "Q0 = 342.0\n",
    "B = 1.9\n",
    "ai = 0.62\n",
    "aw = 0.32\n",
    "\n",
    "# Functions\n",
    "def abar(ys, ai, aw):\n",
    "      return ai + (aw - ai) * ys * (1 - 0.241 * (ys**2 - 1))\n",
    "\n",
    "def a(ys, ai, aw):\n",
    "        if ys == 0:\n",
    "            return aw\n",
    "        else:\n",
    "            return 0.5 * (aw + ai)\n",
    "\n",
    "def s(ys):\n",
    "      return 1 - 0.482 * (3 * ys**2 - 1) / 2\n",
    "\n",
    "def Q(B, A, k, ai, aw):\n",
    "      return ((Tc + A/B) * (B + k)) / (s(0) * (1 - a(0,ai,aw)) + k/B * (1 - abar(0, ai, aw)))\n",
    "\n",
    "# Generate a range of A values\n",
    "k_values = np.linspace(2, 4, 100)\n",
    "\n",
    "# Calculate Q values for each A value\n",
    "Q_values = np.array([Q(B, A, k, ai, aw) for k in k_values])\n",
    "\n",
    "# Plot Q values against A values\n",
    "plt.plot(k_values, Q_values)\n",
    "plt.xlabel(\"B\")\n",
    "plt.ylabel(\"Q\")\n",
    "plt.title(\"Solar constant Q to glaciate Earth vs k\")\n",
    "plt.grid()\n",
    "plt.show()\n",
    "\n",
    "\n",
    "\n",
    "# Calculate Q values for each A value\n",
    "Q_retreat = Q0-Q_values\n",
    "\n",
    "# Plot Q values against A values\n",
    "plt.plot(k_values, Q_retreat)\n",
    "plt.plot([2,4],[0,0],\"--\")\n",
    "plt.xlabel(\"k\")\n",
    "plt.ylabel(\"Q decrease\")\n",
    "plt.title(\"Decrease needed to glaciate Earth vs k\")\n",
    "plt.grid()\n",
    "plt.show()"
   ]

 "A = 202 # outgoing radiation\n",
    "B = 1.9 # outgoing radiation\n",
    "k = 1.6*B # transport parameter\n",
    "s = lambda y: 1 - 0.482*(3*y**2 - 1)/2 # solar weighting\n",
    "aw = 0.32 # water albedo\n",
    "ai = 0.62 # ice albedo\n",
    "Tc = -10.0 # critical temperature for ice formation\n",
    "Q0 = 342.0 # solar constant (1370 W/m^2 divided by 4)\n",
    "aw1 = 0.28\n",
    "aw2 = 0.3\n",
    "aw3 = 0.34\n",
    "aw4 = 0.36\n",
    "aw5 = 0.38\n",
    "aw6 = 0.4\n",
    "ai1 = 0.66\n",
    "ai2 = 0.64\n",
    "ai3 = 0.60\n",
    "ai4 = 0.58\n",
    "ai5 = 0.56\n",
    "ai6 = 0.54\n",
    "\n",
    "Qmin = ((B+k)*(Tc + A/B))/((1-aw)*(s(1)+k/B)) \n",
    "Qmax = ((B+k)*(Tc + A/B))/((1-ai)*(s(0)+k/B))\n",
    "\n",
    "\n",
    "# Note version in lectures was a 1/2 factor off on the second grouping of terms; \n",
    "# now corrected to match Q6 of PS4\n",
    "abar = lambda ys: ai + (aw - ai)*ys*(1 - 0.241*(ys**2 - 1))\n",
    "Qfunc = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "Q1 = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai1+aw1)/2) + k/B*(1 - abar(ys)))\n",
    "Q2 = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai2+aw2)/2) + k/B*(1 - abar(ys)))\n",
    "Q3 = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai3+aw3)/2) + k/B*(1 - abar(ys)))\n",
    "Q4 = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai4+aw4)/2) + k/B*(1 - abar(ys)))\n",
    "Q5 = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai4+aw4)/2) + k/B*(1 - abar(ys)))\n",
    "Q6 = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai5+aw5)/2) + k/B*(1 - abar(ys)))\n",
    "\n",
    "\n",
    "\n",
    "# Solve for the ice line\n",
    "ys = np.linspace(0, 1, 100);\n",
    "Qs = Qfunc(ys);\n",
    "Q1 = Q1(ys)\n",
    "Q2 = Q2(ys)\n",
    "Q3 = Q3(ys)\n",
    "Q4 = Q4(ys)\n",
    "Q5 = Q5(ys)\n",
    "Q6 = Q6(ys)\n",
    "\n",
    "\n",
    "\n",
    "plt.plot(Q1, ys, 'c', label='aw=0.28, ai=0.66')\n",
    "plt.plot(Q2, ys, 'k', label='aw=0.3, ai=0.64')\n",
    "plt.plot(Q3, ys, 'y', label='aw=0.34, ai=0.6')\n",
    "plt.plot(Q4, ys, 'k', label='aw=0.')\n",
    "plt.plot(Q5, ys, 'b', label='B=2.2')\n",
    "plt.plot(Q6, ys, 'g', label='B=2.4')\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "plt.plot([Q0, Q0], [0, 1], '--')\n",
    "plt.plot([250, Qmax], [0, 0], 'b')\n",
    "plt.plot([Qmin, 550], [1, 1], 'b')\n",
    "plt.xlabel('Q');\n",
    "plt.ylabel('ys');\n",
    "plt.grid(1)\n",
    "plt.title('Change in Q critical values as k changes')\n",
    "plt.legend()\n",
    "plt.show()"
   ]


 "A = 202 # outgoing radiation\n",
    "B = 1.9 # outgoing radiation\n",
    "k = 1.6*B # transport parameter\n",
    "s = lambda y: 1 - 0.482*(3*y**2 - 1)/2 # solar weighting\n",
    "aw = 0.32 # water albedo\n",
    "ai = 0.62 # ice albedo\n",
    "Tc = -10.0 # critical temperature for ice formation\n",
    "Q0 = 342.0 # solar constant (1370 W/m^2 divided by 4)\n",
    "aw1 = 0.26\n",
    "aw2 = 0.28\n",
    "aw3 = 0.3\n",
    "aw4 = 0.34\n",
    "aw5 = 0.36\n",
    "aw6 = 0.38\n",
    "ai1 = 0.68\n",
    "ai2 = 0.66\n",
    "ai3 = 0.64\n",
    "ai4 = 0.60\n",
    "ai5 = 0.58\n",
    "ai6 = 0.56\n",
    "\n",
    "Qmin = ((B+k)*(Tc + A/B))/((1-aw)*(s(1)+k/B)) \n",
    "Qmax = ((B+k)*(Tc + A/B))/((1-ai)*(s(0)+k/B))\n",
    "abar = lambda ys: ai + (aw - ai)*ys*(1 - 0.241*(ys**2 - 1))\n",
    "Qfunc = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "Q7 = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai1+aw6)/2) + k/B*(1 - abar(ys)))\n",
    "Q8 = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai2+aw5)/2) + k/B*(1 - abar(ys)))\n",
    "Q9 = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai3+aw4)/2) + k/B*(1 - abar(ys)))\n",
    "Q10 = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai4+aw3)/2) + k/B*(1 - abar(ys)))\n",
    "Q11= lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai5+aw2)/2) + k/B*(1 - abar(ys)))\n",
    "Q12= lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai6+aw1)/2) + k/B*(1 - abar(ys)))\n",
    "\n",
    "ys = np.linspace(0, 1, 100);\n",
    "Qs = Qfunc(ys);\n",
    "Q7 = Q7(ys)\n",
    "Q8 = Q8(ys)\n",
    "Q9 = Q9(ys)\n",
    "Q10 = Q10(ys)\n",
    "Q11 = Q11(ys)\n",
    "Q12 = Q12(ys)\n",
    "\n",
    "plt.plot(Q12, ys, 'c', label='aw=0.26, ai=0.56')\n",
    "plt.plot(Q11, ys, 'k', label='aw=0.28, ai=0.58')\n",
    "plt.plot(Q10, ys, 'y', label='aw=0.3, ai=0.6')\n",
    "plt.plot(Qs, ys, 'm', label='aw=0.32, ai=0.62')\n",
    "plt.plot(Q9, ys, 'k', label='aw=0.34, ai=0.64')\n",
    "plt.plot(Q8, ys, 'b', label='aw=0.36, ai=0.66')\n",
    "plt.plot(Q7, ys, 'g', label='aw=0.38, ai=0.68')\n",
    "\n",
    "\n",
    "plt.plot([Q0, Q0], [0, 1], '--')\n",
    "plt.plot([250, Qmax], [0, 0], 'b')\n",
    "plt.plot([Qmin, 550], [1, 1], 'b')\n",
    "plt.xlabel('Q');\n",
    "plt.ylabel('Ice Line ys');\n",
    "plt.grid(1)\n",
    "plt.title('Change in Q behaviour as ai and aw change')\n",
    "plt.legend()\n",
    "plt.show()"
   ]

"aw = 0.26 # water albedo\n",
    "ai = 0.56 # ice albedo\n",
    "Tc = -10.0 # critical temperature for ice formation\n",
    "Q0 = 342.0 # solar constant (1370 W/m^2 divided by 4)\n",
    "abar= lambda ys : ai + (aw - ai) * ys * (1 - 0.241 * (ys**2 - 1))\n",
    "def a(ys):\n",
    "    if ys == 0:\n",
    "          return aw\n",
    "    else:\n",
    "          return 0.5 * (aw + ai)\n",
    "\n",
    "s = lambda ys : 1 - 0.482 * (3 * ys**2 - 1) / 2\n",
    "\n",
    "Q = lambda ys : ((Tc + A/B) * (B + k)) / (s(ys) * (1 - a(ys)) + k/B * (1 - abar(ys)))\n",
    "ys = 0\n",
    "Q_glaciated = Q(ys)\n",
    "decrease_Q = Q0 - Q_glaciated\n",
    "ys_values = np.linspace(0, 1, 1000)\n",
    "Q_values = [Q(ys) for ys in ys_values]\n",
    "Q_retreat = next(Q_value for Q_value, ys_value in zip(Q_values, ys_values) if Q_value > Q_glaciated and ys_value > 0)\n",
    "increase_Q = Q_retreat - Q_glaciated\n",
    "print(f' At ai=0.26 and aw=0.56, Increase in Q required for the ice to retreat from the equator: {increase_Q}')"
   ]


"aw = 0.38 # water albedo\n",
    "ai = 0.68 # ice albedo\n",
    "Tc = -10.0 # critical temperature for ice formation\n",
    "Q0 = 342.0 # solar constant (1370 W/m^2 divided by 4)\n",
    "abar= lambda ys : ai + (aw - ai) * ys * (1 - 0.241 * (ys**2 - 1))\n",
    "def a(ys):\n",
    "    if ys == 0:\n",
    "          return aw\n",
    "    else:\n",
    "          return 0.5 * (aw + ai)\n",
    "\n",
    "s = lambda ys : 1 - 0.482 * (3 * ys**2 - 1) / 2\n",
    "\n",
    "Q = lambda ys : ((Tc + A/B) * (B + k)) / (s(ys) * (1 - a(ys)) + k/B * (1 - abar(ys)))\n",
    "ys = 0\n",
    "Q_glaciated = Q(ys)\n",
    "decrease_Q = Q0 - Q_glaciated\n",
    "ys_values = np.linspace(0, 1, 1000)\n",
    "Q_values = [Q(ys) for ys in ys_values]\n",
    "Q_retreat = next(Q_value for Q_value, ys_value in zip(Q_values, ys_values) if Q_value > Q_glaciated and ys_value > 0)\n",
    "increase_Q = Q_retreat - Q_glaciated\n",
    "print(f' At ai=0.38 and aw=0.68, Increase in Q required for the ice to retreat from the equator: {increase_Q}')"
   ]


"#INVESTIGATION 2A\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.integrate import solve_ivp\n",
    "\n",
    "# Define the given parameters\n",
    "Q = 342\n",
    "A = 202\n",
    "B = 1.9\n",
    "Tc = -10\n",
    "s_func = lambda y: 1 - (0.482 / 2) * (3 * y**2 - 1)\n",
    "\n",
    "def a_func(y, ys):\n",
    "    ai = 0.62\n",
    "    aw = 0.32\n",
    "    return np.where(y > ys, ai, np.where(y < ys, aw, 0.5 * (aw + ai)))\n",
    "\n",
    "# Define energy terms\n",
    "def E_in(y, t, ys):\n",
    "    return Q * s_func(y) * (1 - a_func(y, ys))\n",
    "\n",
    "def E_out(y, t):\n",
    "    return A + (B * t)\n",
    "\n",
    "def E_transport(y, t, T1, k):\n",
    "    return k * (T1 - t)\n",
    "\n",
    "def find_ice_line(y_values, T_values):\n",
    "    return y_values[np.abs(T_values - Tc).argmin()]\n",
    "\n",
    "def simulate_ebm(k, num_latitudes=100, num_steps=1000, dt=0.01):\n",
    "    latitudes = np.linspace(0, np.pi / 2, num_latitudes)\n",
    "    y_values = np.sin(latitudes)\n",
    "    T_values = np.zeros_like(y_values)\n",
    "    T1 = 0\n",
    "\n",
    "    for step in range(num_steps):\n",
    "        ys = find_ice_line(y_values, T_values)\n",
    "        dT_dt = (E_in(y_values, T_values, ys) - E_out(y_values, T_values) + E_transport(y_values, T_values, T1, k))\n",
    "        T_values += dT_dt * dt\n",
    "\n",
    "    return y_values, T_values\n",
    "\n",
    "k_values = [1.6 * B, 3.74, 3.91]\n",
    "results = []\n",
    "\n",
    "for k in k_values:\n",
    "    y_values, T_values = simulate_ebm(k)\n",
    "    results.append((y_values, T_values))\n",
    "\n",
    "for (y_values, T_values), k in zip(results, k_values):\n",
    "    plt.plot(y_values, T_values, label=f'k = {k:.2f}')\n",
    "    ys = find_ice_line(y_values, T_values)\n",
    "    plt.axvline(x=ys, linestyle='--', color='grey', alpha=0.5)\n",
    "    print(f\"For k = {k:.2f}, the ice line is at y = {ys:.3f}\")\n",
    "\n",
    "plt.xlabel('sin(Latitude) y')\n",
    "plt.ylabel('Steady State Temperature (T)')\n",
    "plt.legend()\n",
    "plt.title('Temperature vs Latitude for Different k Values')\n",
    "plt.grid()\n",
    "plt.show()\n",
    "\n",
    "\n"
   ]

"#INVESTIGATION 2B\n",
    "def plot(k):\n",
    "    A = 202\n",
    "    B = 1.9\n",
    "    s = lambda y: 1 - 0.482 * (3 * y**2 - 1) / 2\n",
    "    aw = 0.32\n",
    "    ai = 0.62\n",
    "    Tc = -10.0\n",
    "    Q0 = 342.0\n",
    "\n",
    "    abar = lambda ys: ai + (aw - ai)*ys*(1 - 0.241*(ys**2 - 1))\n",
    "    Tbar = lambda ys, Q: (Q*(1 - abar(ys)) - A)/B \n",
    "    Tbari = lambda Q: (Q*(1 - ai)- A)/B\n",
    "    Tbarw = lambda Q: (Q*(1 - aw)- A)/B\n",
    "    Qfunc = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "\n",
    "    Qmin = (Tc + A/B)*(B+k)/((1 - aw)*(s(1) + k/B))\n",
    "    Qmax = (Tc + A/B)*(B+k)/((1 - ai)*(s(0) + k/B))\n",
    "    ys = np.linspace(0, 1, 100)\n",
    "    Qs = Qfunc(ys)\n",
    "\n",
    "    plt.plot(Qs, Tbar(ys, Qs), 'k')\n",
    "    Qa = np.linspace(250, Qmax, 5)\n",
    "    plt.plot(Qa, Tbari(Qa), 'g')\n",
    "    Qb = np.linspace(Qmin, 550, 5)\n",
    "    plt.plot(Qb, Tbarw(Qb), 'orange')\n",
    "    plt.plot([Q0, Q0], [-60, 100], '--')\n",
    "    plt.xlabel('Q')\n",
    "    plt.ylabel('Mean Temperature')\n",
    "    plt.title(f'Temperature vs Solar Constant for k = {k}')\n",
    "    plt.grid(1)\n",
    "    plt.savefig(f'Tbar_vs_Q_k_{k}.pdf')\n",
    "    plt.show()\n",
    "\n",
    "# Call the function with different k values\n",
    "plot(0.1)  # k << 1\n",
    "plot(100)  # k >> 1\n",
    "\n",
    "\n",
    "def calculate_sensitivity(k):\n",
    "    A = 202\n",
    "    B = 1.9\n",
    "    s = lambda y: 1 - 0.482 * (3 * y**2 - 1) / 2\n",
    "    aw = 0.32\n",
    "    ai = 0.62\n",
    "    Tc = -10.0\n",
    "    Q0 = 342.0\n",
    "\n",
    "    abar = lambda ys: ai + (aw - ai)*ys*(1 - 0.241*(ys**2 - 1))\n",
    "    Tbar = lambda ys, Q: (Q*(1 - abar(ys)) - A)/B \n",
    "    Qfunc = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "\n",
    "    ys = np.linspace(0, 1, 100)\n",
    "    Qs = Qfunc(ys)\n",
    "    Tbars = Tbar(ys, Qs)\n",
    "    \n",
    "    dTbar_dQ = np.gradient(Tbars, Qs)\n",
    "    \n",
    "    return dTbar_dQ\n",
    "\n",
    "# Calculate the sensitivity for k = 0.1 and k = 100\n",
    "sensitivity_k_small = calculate_sensitivity(0.1)\n",
    "sensitivity_k_large = calculate_sensitivity(100)\n",
    "\n",
    "# Compare the sensitivity for the two cases\n",
    "print(\"Sensitivity (dTbar/dQ) for k = 0.1: \", sensitivity_k_small)\n",
    "print(\"Sensitivity (dTbar/dQ) for k = 100: \", sensitivity_k_large)\n"
   ]


"#INVESTIGATION 3A\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.optimize import root\n",
    "\n",
    "A = 202 # outgoing radiation\n",
    "B = 1.9 # outgoing radiation\n",
    "k = 1.6*B # transport parameter\n",
    "s = lambda y: 1 - 0.482*(3*y**2 - 1)/2 # solar weighting\n",
    "aw = 0.32 # water albedo\n",
    "ai = 0.62 # ice albedo\n",
    "Tc = (0.391*0-13*0.609)# critical temperature for ice formation\n",
    "Tc2 = -10\n",
    "Q0 = 342.0 # solar constant (1370 W/m^2 divided by 4)\n",
    "\n",
    "Qmin = (Tc + A/B)*(B+k)/((1 - aw)*(s(1) + k/B))\n",
    "Qmax = (Tc + A/B)*(B+k)/((1 - ai)*(s(0) + k/B))\n",
    "print(\"Min Q value for ice free\", Qmin)\n",
    "print(\"Max Q value for complete ice Earth\", Qmax)\n",
    "\n",
    "Qmin2 = (Tc2 + A/B)*(B+k)/((1 - aw)*(s(1) + k/B))\n",
    "Qmax2 = (Tc2 + A/B)*(B+k)/((1 - ai)*(s(0) + k/B))\n",
    "print(\"Min Q value for ice free\", Qmin2)\n",
    "print(\"Max Q value for complete ice Earth\", Qmax2)\n",
    "\n",
    "abar = lambda ys: ai + (aw - ai)*ys*(1 - 0.241*(ys**2 - 1))\n",
    "Tbar = lambda ys, Q: (Q*(1 - abar(ys)) - A)/B \n",
    "Tbari = lambda Q: (Q*(1 - ai)- A)/B\n",
    "Tbarw = lambda Q: (Q*(1 - aw)- A)/B\n",
    "Qfunc = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "Qfunc2 = lambda ys: (Tc2 + A/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "\n",
    "# Solve for the ice line\n",
    "ys = np.linspace(0, 1, 100);\n",
    "Qs = Qfunc(ys);\n",
    "Qs2 = Qfunc2(ys);\n",
    "plt.plot(Qs, ys, label='Tc = -7.9')\n",
    "plt.plot(Qs2, ys, label='Tc = -10')\n",
    "plt.plot([Q0, Q0], [0, 1], '--')\n",
    "plt.plot([Qmin, 550], [1, 1])\n",
    "plt.plot([250, Qmax], [0, 0])\n",
    "plt.xlabel('Q');\n",
    "plt.ylabel('Ice Line ys');\n",
    "plt.grid(1)\n",
    "plt.legend()\n",
    "plt.title('Ice Line against the Solar Constant for different Critical Temperatures')\n",
    "\n",
    "# We can obtain the ice-line positions via Newton's. \n",
    "fwd = lambda ys: Q0 - Qfunc(ys)\n",
    "sol = root(fwd, 0.2)\n",
    "print(sol.message)\n",
    "ys_low = sol.x[0]\n",
    "print(\"lower ice line = \", ys_low)\n",
    "sol = root(fwd, 0.9)\n",
    "print(sol.message)\n",
    "ys_high = sol.x[0]\n",
    "print(\"higher ice line = \", ys_high)\n",
    "\n",
    "fwd2 = lambda ys: Q0 - Qfunc2(ys)\n",
    "sol2 = root(fwd2, 0.2)\n",
    "print(sol2.message)\n",
    "ys_low2 = sol2.x[0]\n",
    "print(\"lower ice line = \", ys_low2)\n",
    "sol2 = root(fwd2, 0.9)\n",
    "print(sol2.message)\n",
    "ys_high2 = sol2.x[0]\n",
    "print(\"higher ice line = \", ys_high2)\n"
   ]

"# Plot mean temperature vs. Q\n",
    "plt.plot(Qs, Tbar(ys, Qs), 'k', label='Tc=-7.9')\n",
    "plt.plot(Qs2, Tbar(ys, Qs2), 'red', label='Tc=-10')\n",
    "Qa = np.linspace(250, Qmax, 5)\n",
    "plt.plot(Qa, Tbari(Qa), 'g')\n",
    "Qb = np.linspace(Qmin, 550, 5)\n",
    "plt.plot(Qb, Tbarw(Qb), 'orange')\n",
    "plt.plot([Q0, Q0], [-60, 100], '--')\n",
    "plt.xlabel('Q')\n",
    "plt.legend()\n",
    "plt.title('Mean Temperature of the Earth against Q for different Critical Temperatures')\n",
    "plt.ylabel('Steady State Temperature')\n",
    "plt.grid(1)\n",
    "plt.savefig('Tbar_vs_Q.pdf')\n"
   ]

"#INVESTIGATION 3B\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.optimize import root\n",
    "\n",
    "A = 202 # outgoing radiation\n",
    "B = 1.9 # outgoing radiation\n",
    "k = 1.6*B # transport parameter\n",
    "s = lambda y: 1 - 0.482*(3*y**2 - 1)/2 # solar weighting\n",
    "aw = 0.32 # water albedo\n",
    "ai = 0.62 # ice albedo\n",
    "ai1 = 0.5\n",
    "ai2 = 0.8\n",
    "ai3 = 0.7\n",
    "Tc = -10 # critical temperature for ice formation\n",
    "Q0 = 342.0 # solar constant (1370 W/m^2 divided by 4)\n",
    "\n",
    "Qmin = (Tc + A/B)*(B+k)/((1 - aw)*(s(1) + k/B))\n",
    "Qmax = (Tc + A/B)*(B+k)/((1 - ai)*(s(0) + k/B))\n",
    "print(\"Min Q value for ice free\", Qmin)\n",
    "print(\"Max Q value for complete ice Earth\", Qmax)\n",
    "\n",
    "abar = lambda ys: ai + (aw - ai)*ys*(1 - 0.241*(ys**2 - 1))\n",
    "Tbar = lambda ys, Q: (Q*(1 - abar(ys)) - A)/B \n",
    "Tbari1 = lambda Q: (Q*(1 - ai1)- A)/B\n",
    "Tbari2 = lambda Q: (Q*(1 - ai2)- A)/B\n",
    "Tbari3 = lambda Q: (Q*(1 - ai3)- A)/B\n",
    "Tbarw = lambda Q: (Q*(1 - aw)- A)/B\n",
    "Qfunc = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "\n",
    "Qfunc1 = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai1+aw)/2) + k/B*(1 - abar(ys)))\n",
    "Qfunc2 = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai2+aw)/2) + k/B*(1 - abar(ys)))\n",
    "Qfunc3 = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai3+aw)/2) + k/B*(1 - abar(ys)))\n",
    "\n",
    "# Solve for the ice line\n",
    "ys = np.linspace(0, 1, 100);\n",
    "Qs = Qfunc(ys);\n",
    "Qs1 = Qfunc1(ys);\n",
    "Qs2 = Qfunc2(ys);\n",
    "Qs3 = Qfunc3(ys);\n",
    "\n",
    "plt.plot(Qs, ys, label='ai=0.62')\n",
    "plt.plot(Qs1, ys, label='ai=0.5')\n",
    "plt.plot(Qs3, ys, label='ai=0.7')\n",
    "plt.plot(Qs2, ys, label='ai=0.8')\n",
    "\n",
    "plt.plot([Q0, Q0], [0, 1], '--')\n",
    "plt.plot([Qmin, 550], [1, 1], 'b')\n",
    "plt.plot([250, Qmax], [0, 0], 'b')\n",
    "plt.xlabel('Q');\n",
    "plt.ylabel('Ice Line ys');\n",
    "plt.grid(1)\n",
    "plt.legend()\n",
    "plt.title('Ice Line against the Solar Constant for different Ice Albedos')\n",
    "\n",
    "# We can obtain the ice-line positions via Newton's. \n",
    "fwd = lambda ys: Q0 - Qfunc(ys)\n",
    "sol = root(fwd, 0.2)\n",
    "print(sol.message)\n",
    "ys_low = sol.x[0]\n",
    "print(\"lower ice line when ai=0.62 = \", ys_low)\n",
    "sol = root(fwd, 0.9)\n",
    "print(sol.message)\n",
    "ys_high = sol.x[0]\n",
    "print(\"higher ice line when ai=0.62 = \", ys_high)\n",
    "\n",
    "fwd1 = lambda ys: Q0 - Qfunc1(ys)\n",
    "sol1 = root(fwd1, 0.2)\n",
    "print(sol1.message)\n",
    "ys_low1 = sol1.x[0]\n",
    "print(\"lower ice line when ai=0.5 = \", ys_low1)\n",
    "sol1 = root(fwd1, 0.9)\n",
    "print(sol1.message)\n",
    "ys_high1 = sol1.x[0]\n",
    "print(\"higher ice line when ai=0.5 = \", ys_high1)\n",
    "\n",
    "fwd3 = lambda ys: Q0 - Qfunc3(ys)\n",
    "sol3 = root(fwd3, 0.2)\n",
    "print(sol3.message)\n",
    "ys_low3 = sol3.x[0]\n",
    "print(\"lower ice line when ai=0.7 = \", ys_low3)\n",
    "sol3 = root(fwd3, 0.9)\n",
    "print(sol3.message)\n",
    "ys_high3 = sol3.x[0]\n",
    "print(\"higher ice line when ai=0.7 = \", ys_high3)\n",
    "\n",
    "fwd2 = lambda ys: Q0 - Qfunc2(ys)\n",
    "sol2 = root(fwd2, 0.2)\n",
    "print(sol2.message)\n",
    "ys_low2 = sol2.x[0]\n",
    "print(\"lower ice line when ai=0.8 = \", ys_low2)\n",
    "sol2 = root(fwd2, 0.9)\n",
    "print(sol2.message)\n",
    "ys_high2 = sol2.x[0]\n",
    "print(\"higher ice line when ai=0.8 = \", ys_high2)\n"
   ]

"#INVESTIGATION 4A\n",
    "#MEAN TEMP ACROSS ICE LINES FOR BUDYKO/CESS\n",
    "\n",
    "Tc = -10 # Critical temperature for ice formation\n",
    "Q = 342 # Solar constant (1380 W/m^2 divided by 4)\n",
    "s = lambda y: 1 - 0.482*(3*y**2 - 1)/2 # Solar weighting\n",
    "aw = 0.32 # Water albedo\n",
    "ai = 0.62 # Ice albedo\n",
    "abar = lambda ys: ai + (aw - ai)*ys*(1 - 0.241*(ys**2 - 1))\n",
    "\n",
    "# Budkyo\n",
    "A_b = 202\n",
    "B_b = 1.45\n",
    "# Cess\n",
    "A_c = 212\n",
    "B_c = 1.60\n",
    "\n",
    "# Discretise y into a mesh of points and plot\n",
    "ys = np.linspace(0, 1, 100)\n",
    "Tbar_exact_budkyo = (Q*(1 - abar(ys)) - A_b)/B_b\n",
    "Tbar_exact_cess = (Q*(1 - abar(ys)) - A_c)/B_c\n",
    "\n",
    "plt.plot(ys, Tbar_exact_budkyo)\n",
    "plt.plot(ys, Tbar_exact_cess)\n",
    "plt.xlabel('Ice line ys'); \n",
    "plt.ylabel('Steady-state temperature T');\n",
    "plt.title('Steady state temperature as the ice line varies')\n",
    "plt.legend(['Budyko', 'Cess']);\n",
    "plt.grid(1);\n",
    "\n",
    "\n"
   ]

"#INVESTIGATION 4B\n",
    "#MEAN TEMP ACROSS ICE LINES AS B VARIES\n",
    "\n",
    "Q = 342 # Solar constant (1380 W/m^2 divided by 4)\n",
    "A = 202\n",
    "Tc = -10 # Critical temperature for ice formation\n",
    "s = lambda y: 1 - 0.482*(3*y**2 - 1)/2 # Solar weighting\n",
    "aw = 0.32 # Water albedo\n",
    "ai = 0.62 # Ice albedo\n",
    "abar = lambda ys: ai + (aw - ai)*ys*(1 - 0.241*(ys**2 - 1))\n",
    "\n",
    "# Discretise y into a mesh of points and plot\n",
    "ys = np.linspace(0, 1, 100)\n",
    "B_vals = [1.45, 1.60, 1.75, 1.90, 2.05, 2.30, 2.45, 2.60]\n",
    "\n",
    "def temp(ys, B):\n",
    "    Tbar = (Q*(1 - abar(ys)) - A)/B\n",
    "    return Tbar\n",
    "\n",
    "T = np.zeros((len(B_vals), len(ys)))\n",
    "for i, B in enumerate(B_vals):\n",
    "    T[i] = temp(ys, B)\n",
    "    \n",
    "for i, B in enumerate(B_vals):\n",
    "    plt.plot(ys, T[i], label='B = {:.2f}'.format(B_vals[i]))   \n",
    "    \n",
    "plt.xlabel('Ice line ys'); \n",
    "plt.ylabel('Steady-state temperature T');\n",
    "plt.title('Steady state temperature as ice line varies for fixed A=202m-2')\n",
    "plt.legend()\n",
    "plt.grid(1);"
   ]


"#INVESTIGATION 5A\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.optimize import root\n",
    "\n",
    "A = 202 # outgoing radiation\n",
    "B = 1.9 # outgoing radiation\n",
    "k = 1.6*B # transport parameter\n",
    "s = lambda y: 1 - 0.482*(3*y**2 - 1)/2 # solar weighting\n",
    "aw = 0.32 # water albedo\n",
    "ai = 0.62 # ice albedo\n",
    "Tc = (0.391*0-13*0.609)# critical temperature for ice formation\n",
    "Tc2 = -10.4\n",
    "Q0 = 342.0 # solar constant (1370 W/m^2 divided by 4)\n",
    "\n",
    "Qmin = (Tc + A/B)*(B+k)/((1 - aw)*(s(1) + k/B))\n",
    "Qmax = (Tc + A/B)*(B+k)/((1 - ai)*(s(0) + k/B))\n",
    "print(\"Min Q value for ice free\", Qmin)\n",
    "print(\"Max Q value for complete ice Earth\", Qmax)\n",
    "\n",
    "Qmin2 = (Tc2 + A/B)*(B+k)/((1 - aw)*(s(1) + k/B))\n",
    "Qmax2 = (Tc2 + A/B)*(B+k)/((1 - ai)*(s(0) + k/B))\n",
    "print(\"Min Q value for ice free\", Qmin2)\n",
    "print(\"Max Q value for complete ice Earth\", Qmax2)\n",
    "\n",
    "abar = lambda ys: ai + (aw - ai)*ys*(1 - 0.241*(ys**2 - 1))\n",
    "Tbar = lambda ys, Q: (Q*(1 - abar(ys)) - A)/B \n",
    "Tbari = lambda Q: (Q*(1 - ai)- A)/B\n",
    "Tbarw = lambda Q: (Q*(1 - aw)- A)/B\n",
    "Qfunc = lambda ys: (Tc + A/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "Qfunc2 = lambda ys: (Tc2 + A/B)*(B+k)/(s(ys)*(1 - (ai+aw)/2) + k/B*(1 - abar(ys)))\n",
    "\n",
    "# Solve for the ice line\n",
    "ys = np.linspace(0, 1, 100);\n",
    "Qs = Qfunc(ys);\n",
    "Qs2 = Qfunc2(ys);\n",
    "plt.plot(Qs, ys, label='Tc = -7.9')\n",
    "plt.plot(Qs2, ys, label='Tc = -10.4')\n",
    "plt.plot([Q0, Q0], [0, 1], '--')\n",
    "plt.plot([Qmin, 550], [1, 1])\n",
    "plt.plot([250, Qmax], [0, 0])\n",
    "plt.xlabel('Q');\n",
    "plt.ylabel('Ice Line ys');\n",
    "plt.grid(1)\n",
    "plt.legend()\n",
    "plt.title('Ice Line against Q for Northen and Southern Hemispheres')\n",
    "\n",
    "fwd = lambda ys: Q0 - Qfunc(ys)\n",
    "sol = root(fwd, 0.2)\n",
    "print(sol.message)\n",
    "ys_low = sol.x[0]\n",
    "print(\"lower ice line = \", ys_low)\n",
    "sol = root(fwd, 0.9)\n",
    "print(sol.message)\n",
    "ys_high = sol.x[0]\n",
    "print(\"higher ice line = \", ys_high)\n",
    "\n",
    "fwd2 = lambda ys: Q0 - Qfunc2(ys)\n",
    "sol2 = root(fwd2, 0.2)\n",
    "print(sol2.message)\n",
    "ys_low2 = sol2.x[0]\n",
    "print(\"lower ice line = \", ys_low2)\n",
    "sol2 = root(fwd2, 0.9)\n",
    "print(sol2.message)\n",
    "ys_high2 = sol2.x[0]\n",
    "print(\"higher ice line = \", ys_high2)\n"
   ]


"from scipy.optimize import root\n",
    "from scipy.interpolate import interp1d\n",
    "\n",
    "A = 202 # outgoing radiation\n",
    "B = 1.9 # outgoing radiation\n",
    "k = 1.6*B # transport parameter\n",
    "s = lambda y: 1 - 0.482*(3*y**2 - 1)/2 # solar weighting\n",
    "aw = 0.32 # water albedo\n",
    "ai = 0.62 # ice albedo\n",
    "Tc = -10.0 # critical temperature for ice formation\n",
    "Q = 342.0 # solar constant (1380 W/m^2 divided by 4)\n",
    "\n",
    "def Tbar(y, T):\n",
    "    # Riemann sum approximation of the integral T(y) over y    \n",
    "    I = 0\n",
    "    for i in range(0, np.size(y)-1):\n",
    "        dy = y[i+1] - y[i]\n",
    "        I = I + T[i]*dy\n",
    "        # print(i, yi, T[i])\n",
    "        # I = I + 0.5*(T[i] + T[i+1])*dy\n",
    "    return I\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "def afunc(T, Tc= -10, aw = 0.32, ai=0.62, j=0.1):\n",
    "    a = np.zeros(len(T))\n",
    "    \n",
    "    for i, temp in enumerate(T):\n",
    "        a[i] = ai + (aw - ai) / (1 + np.exp(-j * (temp - Tc)))\n",
    "    \n",
    "    return a\n",
    "\n",
    "\n",
    "def myF(T, y):\n",
    "    Tb = Tbar(y, T)\n",
    "    Phi = (k*Tb + Q*s(y)*(1 - afunc(T)) - A)/(B+k)\n",
    "    F = T - Phi\n",
    "    return F\n",
    "\n",
    "def myPhi(T, y):\n",
    "    Tb = Tbar(y, T)\n",
    "    Phi = (k*Tb + Q*s(y)*(1 - afunc(T)) - A)/(B+k)\n",
    "    return Phi\n",
    "# Initialise the mesh with N points\n",
    "N = 51\n",
    "y = np.linspace(0, 1, N)\n",
    "\n",
    "# Iterative scheme\n",
    "# Form an initial guess \n",
    "# Try this one for the fake solution\n",
    "Tequator = 20; Tpole = -12;\n",
    "# Try this one for the true solution\n",
    "# Tequator = 20\n",
    "# Tpole = -12\n",
    "T = Tequator + (Tpole - Tequator)*y\n",
    "# T = 0*y - 9.5\n",
    "# T = 0*y - 30\n",
    "# T = 0*y + 30\n",
    "\n",
    "# Run the solver\n",
    "fwd = lambda T: T - myPhi(T, y)\n",
    "sol = root(fwd, T)\n",
    "print(sol.message)\n",
    "\n",
    "# Plot the output\n",
    "solT = sol.x;\n",
    "fig = plt.figure(figsize=(6,4))\n",
    "plt.plot(y, solT, '-')\n",
    "plt.xlabel('sin(Latitude) y'); plt.ylabel('T')\n",
    "plt.title(\"Mean temperature = %1.3f\" % Tbar(y, solT));"
   ]


"C = 10\n",
    "A = 202\n",
    "B = 1.9\n",
    "Q = 342\n",
    "T_C = -10\n",
    "y_max = 1\n",
    "n = 100\n",
    "t_max = 1000\n",
    "dy = y_max / n\n",
    "\n",
    "# Functions\n",
    "def albedo(y, T, ys):\n",
    "    aw = 0.32\n",
    "    ai = 0.62\n",
    "    s = 1 - (0.482 / 2) * (3 * y**2 - 1)\n",
    "    a = np.where(T >= T_C, aw, ai)\n",
    "    a[np.abs(y - ys) < 1e-6] = 0.5 * (aw + ai)\n",
    "    return a * s\n",
    "\n",
    "def E_in(y, T, ys):\n",
    "    return Q * (1 - albedo(y, T, ys))\n",
    "\n",
    "def E_out(T):\n",
    "    return A + B * T\n",
    "\n",
    "def dTdt(T, k):\n",
    "    n = len(T)\n",
    "    dy = 2 / (n - 1)\n",
    "    dTdt = np.zeros(n)\n",
    "    for i in range(1, n - 1):\n",
    "        dT2dy2 = (T[i + 1] - 2 * T[i] + T[i - 1]) / dy**2\n",
    "        dTdt[i] = k * dT2dy2 - E_out(T[i]) + E_in(y[i], T[i], ys)\n",
    "    return dTdt\n",
    "\n",
    "# Define range of k values\n",
    "k_values = [0.1, 3.04, 3.74, 3.91, 100]\n",
    "\n",
    "# Function for solving the EBM\n",
    "def ebm_ode(t, T, k):\n",
    "    return dTdt(T, k)\n",
    "\n",
    "for k in k_values:\n",
    "    y = np.linspace(0, y_max, n)\n",
    "    T0 = np.zeros(n)\n",
    "    ys = 0\n",
    "\n",
    "    # Numerical solution of EBM\n",
    "    sol = solve_ivp(ebm_ode, (0, t_max), T0, args=(k,), method='BDF', rtol=1e-6, atol=1e-9)\n",
    "    T = sol.y[:, -1]\n",
    "    ys = np.interp(T_C, T[::-1], y[::-1]) # Ice line at T_C\n",
    "\n",
    "    # Plot temperature profiles\n",
    "    plt.plot(y, T, label=f'k={k:.2f}')\n",
    "\n",
    "plt.xlabel('sin(Latitude) y')\n",
    "plt.ylabel('Temperature (C)')\n",
    "plt.title('Temperature profiles for different values of k')\n",
    "plt.legend()\n",
    "plt.show()\n",
    "\n"
   ]
